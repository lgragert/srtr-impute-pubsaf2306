###############################################################################
#   SCRIPT NAME:    hlaR_eplet_matrix_generation_array_I10.R
#   DESCRIPTION:    Generate eplet MM matrix for all Imputations
#   OUTPUT:         Imp_%a_hlaR_eplet_only_matrix_%a.csv
#   DATE:           February 23, 2023
#   AUTHOR:         Grace Lord (gwager@tulane.edu ; GitHub: gwager)
#   PI:             Loren Gragert, Ph.D.
#   ORGANIZATION:   Tulane University School of Medicine
#   NOTES:
###############################################################################
if(!require("dtplyr"))
  install.packages("dtplyr")
if(!require("dplyr"))
  install.packages("dplyr")
if (!require("tidyverse"))
  install.packages("tidyverse")
if (!require("dplyr"))
  install.packages("dplyr")
if (!require("plyr"))
  install.packages("plyr")
if (!require("tidyr"))
  install.packages("tidyr")
if (!require("stringr"))
  install.packages("stringr")
if (!require("scales"))
  install.packages("scales")
if (!require("data.table"))
  installed.packages("data.table")
if (!require("rlang"))
  installed.packages("rlang")
if (!require("cli"))
  installed.packages("cli")
if (!require("devtools"))
  installed.packages("devtools")
if (!require("tidyselect"))
  install.packages("tidyselect")
if (!require("readr"))
  install.packages("readr")


#Eplet reference tables are extracted from the HLAMatchMaker workbooks version 
#2.1 and 3.1 (http://www.epitopes.net/index.html). We have verified the results generated by hlaR in comparison to HLAMatchMaker. There are a small number of typographical errors in the HLAMatchMaker excel files that result in eplets identified in the reference table not carrying over to the results. Because of these errors, the eplet mismatch on hlaR is occasionally one or two points higher than that output by the excel files. If an allele from the input data is not present in the reference table, the result generated will be NA. 

#dat<-read.csv(system.file("extdata/example","MHC_II_test.csv",package="hlaR"),sep=",",header=TRUE)
#re <- CalEpletMHCII(dat, ver = 2)


#Step 1 fetch all necessary files and filter for
  #hlaR output only for Specific Loci of interest


#fetch hlaR files
command_args <- commandArgs(trailingOnly = TRUE)
IMP_ID<-paste0(split <- command_args[1])
Format_ID<-paste0(split <- command_args[2])

#IMP_ID = 1
# filename <- paste0("IMP_",IMP_ID ,"_hlaRepletsListclassIIA_")
# print(filename)
# hlaRDDCII <- dir(path="./hlaR_February_22_2023", pattern= filename, full.names=TRUE, recursive = TRUE)
# eplets <- do.call(`rbind`,lapply(hlaRDDCII, read.table, header=T, sep=","))
# colnames(eplets)[which(names(eplets) == "pair_id")] <- "PX_ID"

filename <- paste0("./hlaR_March23/Imp_",IMP_ID , "_hlaRepletsListclassIIA_", Format_ID, ".csv")
print(paste0("filename:",filename ))

eplets <- read.table(filename, sep = ',',header = TRUE)
colnames(eplets)[which(names(eplets) == "pair_id")] <- "PX_ID"


id_list <- unique(as.list(eplets$PX_ID))
myvalue <- as.numeric(length(id_list))



#filter eplets into loci groups to be utilized in later loop
DQA <- filter(eplets, str_detect(hla, "DQA"))
DQB <- filter(eplets, str_detect(hla, "DQB"))
DRB <- filter(eplets, str_detect(hla, "DRB1"))
DRW <- filter(eplets, str_detect(hla, c("DRB3","DRB4","DRB5")))




##Step II Genrate DQA DQB DRB and DRW Eplet MM lists 
#and convert into an empty matrix

#fetch Eplet MM lists from HlaR downloaded from github repository
II3A <- read.table("./MHC_II_eplet_A_v3.csv", sep = ',',header = T)
II3B <- read.table("./MHC_II_eplet_B_v3.csv", sep = ',',header = T)

#Turn DR and DQ eplet MM into a list for colum n names
II3A <- II3A %>% dplyr::select(starts_with("DQ"))
II3B_DQB <- II3B %>% dplyr::select(starts_with("DQB"))
II3B_DRB <- II3B %>% dplyr::select(starts_with("DRB1"))
II3B_DRW <- II3B %>% dplyr::select(starts_with("DRB3"),
                               starts_with("DRB4"),starts_with("DRB5"))


II3DQA <- data.frame(DQA=unlist(II3A))
II3DQA<-II3DQA[! (II3DQA$DQA==""), ]
II3DQA <-data.frame(unique(II3DQA))
II3DQA$DQA <- "DQA_"
II3DQA$DQAeplets <- paste(II3DQA$DQA, II3DQA$unique.II3DQA.)
DQA_3list <- data.frame(II3DQA$DQAeplets)
colnames(DQA_3list)[1] = "Eplets"


II3DQB <- data.frame(DQB=unlist(II3B_DQB))
II3DQB<-II3DQB[! (II3DQB$DQB==""), ]
II3DQB <-data.frame(unique(II3DQB))
II3DQB$DQB <- "DQB_"
II3DQB$DQBeplets <- paste(II3DQB$DQB, II3DQB$unique.II3DQB.)
DQB_3list <- data.frame(II3DQB$DQBeplets)
colnames(DQB_3list)[1] = "Eplets"


II3DRB <- data.frame(DRB=unlist(II3B_DRB))
II3DRB<-II3DRB[! (II3DRB$DRB==""), ]
II3DRB <-data.frame(unique(II3DRB))
II3DRB$DRB <- "DRB_"
# not sure what value or number
#of spaces is there so just deleting the row
#GOES FROM 98 TO 97 EPLETS AND NO BLANK SPACES
II3DRB <- data.frame(II3DRB[-37,])
II3DRB$DRBeplets <- paste(II3DRB$DRB, II3DRB$unique.II3DRB.)
DRB_3list <- data.frame(II3DRB$DRBeplets)
colnames(DRB_3list)[1] = "Eplets"


II3DRW <- data.frame(DRW=unlist(II3B_DRW))
II3DRW<-II3DRW[! (II3DRW$DRW==""), ]
II3DRW <-data.frame(unique(II3DRW))
II3DRW$DRW <- "DRW_"
II3DRW$DRWeplets <- paste(II3DRW$DRW, II3DRW$unique.II3DRW.)
DRW_3list <- data.frame(II3DRW$DRWeplets)
colnames(DRW_3list)[1] = "Eplets"

PX <- "PX_ID"


eplet_cols <- rbind(PX,DQA_3list,DQB_3list,DRB_3list,DRW_3list)
my.names <- eplet_cols[,1]
epletvalue <- as.numeric(nrow(eplet_cols))
eps <- data.frame(matrix(, nrow=epletvalue , ncol=myvalue))
colnames(eps) <- id_list
eps <- cbind(eplet_cols, eps)
rownames(eps) <- my.names
eps$Eplets <- gsub(" ", "", eps$Eplets)


###Step 3: Go through the matrix to assign booleon values of eplet MM
#Add Eplet MM column values by PX_IDS
master_eps <- data.frame(matrix(, nrow=epletvalue , ))
rownames(master_eps) <- my.names

for (subject in id_list){
  print(subject)
  id <- as.numeric(subject)
  cid <- as.character(subject)
  
  px_frame <- filter(DQA, PX_ID == id)
  px_frame1 <- filter(px_frame, haplotype_id == 1)
  px_frame2 <- filter(px_frame, haplotype_id == 2)
  
  IIL1DQA <- as.character(px_frame1$mm_eplets)
  IIL1DQA<-unlist(strsplit(IIL1DQA,","))
  DQAL1 <- paste0("DQA_", IIL1DQA)
  
  IIL2DQA <- as.character(px_frame2$mm_eplets)
  IIL2DQA<-unlist(strsplit(IIL2DQA,","))
  DQAL2 <- paste0("DQA_", IIL2DQA)
  
  px_frame <- filter(DQB, PX_ID == id)
  px_frame1 <- filter(px_frame, haplotype_id == 1)
  px_frame2 <- filter(px_frame, haplotype_id == 2)
  
  IIL1DQB <- as.character(px_frame1$mm_eplets)
  IIL1DQB<-unlist(strsplit(IIL1DQB,","))
  DQBL1 <- paste0("DQB_", IIL1DQB)
  
  IIL2DQB <- as.character(px_frame2$mm_eplets)
  IIL2DQB<-unlist(strsplit(IIL2DQB,","))
  DQBL2 <- paste0("DQB_", IIL2DQB)
  
  px_frame <- filter(DRB, PX_ID == id)
  px_frame1 <- filter(px_frame, haplotype_id == 1)
  px_frame2 <- filter(px_frame, haplotype_id == 2)
  
  IIL1DRB <- as.character(px_frame1$mm_eplets)
  IIL1DRB<-unlist(strsplit(IIL1DRB,","))
  DRBL1 <- paste0("DRB_", IIL1DRB)
  
  IIL2DRB <- as.character(px_frame2$mm_eplets)
  IIL2DRB<-unlist(strsplit(IIL2DRB,","))
  DRBL2 <- paste0("DRB_", IIL2DRB)
  
  px_frame <- filter(DRW, PX_ID == id)
  px_frame1 <- filter(px_frame, haplotype_id == 1)
  px_frame2 <- filter(px_frame, haplotype_id == 2)
  
  IIL1DRW <- as.character(px_frame1$mm_eplets)
  IIL1DRW<-unlist(strsplit(IIL1DRW,","))
  DRWL1 <- paste0("DRW_", IIL1DRW)
  
  IIL2DRW <- as.character(px_frame2$mm_eplets)
  IIL2DRW<-unlist(strsplit(IIL2DRW,","))
  DRWL2 <- paste0("DRW_", IIL2DRW)
  
  D1_list <- c(DQAL1,DQBL1,DRBL1,DRWL1)
  D2_list <- c(DQAL2,DQBL2,DRBL2,DRWL2)
  D_list <- c(DQAL1,DQBL1,DRBL1,DRWL1,DQAL2,DQBL2,DRBL2,DRWL2)
  D2list <- intersect(D1_list,D2_list)
  D1list <- setdiff(D_list,D2list)
  eps_subset <- eps %>% dplyr::select("Eplets",cid)
  for (j in 1:ncol(eps_subset)){
    if (j == 1L){          
      e_subset <- eps_subset[j]
    }else{
      D_subset <- filter(eps_subset, Eplets %in% D1list)
      D2_subset <- filter(eps_subset, Eplets %in% D2list)
      
      if (nrow(D_subset) > 1){
        #print(j)
        D_subset[j]<- 1
        if (nrow(D2_subset) > 1){
          #print(j)
          D2_subset[j]<- 2
          D_subset <- full_join(D_subset,D2_subset)
        }
        #else statement to include individuals with zero Ep MMs
      }else{ eps_subset[j]<- 0
      D_subset <- eps_subset
      }
      j_subset <- merge(x = e_subset, y = D_subset, by = "Eplets", all = T)
      master_eps <- cbind(master_eps,j_subset[j])
    }
  }
}


master_eps <- as.data.frame(t(master_eps))
master_eps[,1] <- row.names(master_eps)
master_eps <- master_eps[ -1, ]

master_eps[is.na(master_eps)] <- 0
master_eps$PX_ID <- as.numeric(master_eps$PX_ID)

E_filename <- paste0("./hlaR_March23/Imp_",IMP_ID,"_hlaR_eplet_only_matrix",Format_ID ,".csv")

#print(R_filename)
write.table(master_eps,file=paste0(E_filename), sep = ",", row.names = F)
